# 炼丹系统架构详解

## 一、完整流程图

### 1.1 系统交互流程

```
用户交互 (Alchemy.vue)
    ↓
  ├─ 选择丹方
  │  └─ unlockedRecipes (已掌握列表)
  │
  ├─ 查看材料需求
  │  ├─ selectedRecipe (选中配方)
  │  └─ getMaterialStatus (拥有/需要)
  │
  ├─ 预览效果
  │  └─ currentEffect (计算后的效果)
  │
  └─ 点击炼制
     ├─ checkMaterials() ✓
     ├─ 计算成功率
     ├─ Math.random() 判定
     ├─ 成功: 消耗材料 → 创建丹药 → 更新统计
     └─ 失败: 消耗材料 → 日志记录
```

### 1.2 丹方获取流程

```
探索系统 / 购买系统
      ↓
   获得丹方残页
      ↓
  gainPillFragment()
      ↓
  pillFragments[id]++
      ↓
检查是否达到需求数量
      ↓
  ├─ 未达到 → 提示进度
  └─ 已达到 →
     ├─ 消耗残页
     ├─ pillRecipes.push(id)
     ├─ statsStore.unlockedPillRecipes++
     └─ 成就检查
```

---

## 二、数据结构详解

### 2.1 丹方对象结构

```javascript
{
  id: string,                    // 唯一标识符
  name: string,                  // 显示名称
  description: string,           // 功能描述
  grade: 'grade1' | 'grade2'    // 品阶 (1-9)
    |... | 'grade9',
  type: 'spirit'|'cultivation'  // 类型
      |'attribute'|'special',
  materials: [                   // 材料列表
    {
      herb: string,             // 灵草ID
      count: number             // 需要数量
    },
    ...
  ],
  fragmentsNeeded: number,       // 需要残页数
  baseEffect: {                  // 基础效果
    type: string,               // 效果类型
    value: number,              // 效果值
    duration: number            // 持续秒数
  }
}
```

### 2.2 灵草对象结构

```javascript
// 库存中的灵草
{
  id: string,                   // herb ID
  name: string,                 // 显示名称
  quality: 'common'|'uncommon'|'rare'|'epic'|'legendary',
  value: number,                // 实际价值
  // 以下为配置字段
  baseValue: number,            // 基础价值
  category: string,             // 分类
  chance: number,               // 获取概率
  description: string           // 描述
}
```

### 2.3 丹药对象结构

```javascript
{
  id: string,                   // ${recipeId}_${timestamp}
  name: string,                 // 丹药名称
  description: string,          // 丹药描述
  type: 'pill',                 // 类型标记
  effect: {
    type: string,              // 效果类型
    value: number,             // 计算后的效果值
    duration: number,          // 持续秒数
    successRate: number        // 成功率百分比
  }
}
```

---

## 三、关键函数分析

### 3.1 效果计算函数

```javascript
/**
 * 计算丹药实际效果
 * @param {Object} recipe - 丹方配置
 * @param {number} playerLevel - 玩家等级
 * @returns {Object} 计算后的效果对象
 */
export const calculatePillEffect = (recipe, playerLevel) => {
  // 步骤1：获取品阶配置
  const grade = pillGrades[recipe.grade]
  // grade = { name: '一品', difficulty: 1, successRate: 0.9 }
  
  // 步骤2：获取类型倍数
  const type = pillTypes[recipe.type]
  // type = { name: '灵力类', effectMultiplier: 1 }
  
  // 步骤3：计算等级倍数
  // 公式：1 + (等级 - 1) × 0.1
  // 等级1: 1.0, 等级10: 1.9, 等级20: 2.9
  const levelMultiplier = 1 + (playerLevel - 1) * 0.1
  
  // 步骤4：计算最终效果
  // 最终效果 = 基础 × 类型 × 等级
  return {
    type: recipe.baseEffect.type,
    value: recipe.baseEffect.value 
           × type.effectMultiplier 
           × levelMultiplier,
    duration: recipe.baseEffect.duration,
    successRate: grade.successRate
  }
}
```

**示例调用**：
```javascript
// 场景：等级15的玩家看聚灵丹
const recipe = pillRecipes[0]  // 聚灵丹
const effect = calculatePillEffect(recipe, 15)

// 计算过程：
// levelMultiplier = 1 + (15-1) × 0.1 = 2.4
// value = 0.2 × 1.0 × 2.4 = 0.48

// 结果
effect = {
  type: 'spiritRate',
  value: 0.48,  // 48%
  duration: 3600,
  successRate: 0.9
}
```

### 3.2 材料检查函数

```javascript
/**
 * 检查材料是否充足
 * @param {Object} recipe - 丹方配置
 * @returns {boolean} 是否充足
 */
const checkMaterials = (recipe) => {
  // 遍历丹方需要的每种材料
  for (const material of recipe.materials) {
    // 统计背包中该灵草的数量
    const ownedCount = inventoryStore.herbs.filter(
      h => h.id === material.herb
    ).length
    
    // 如果数量不足，返回false
    if (ownedCount < material.count) {
      return false
    }
  }
  
  // 所有材料都充足
  return true
}
```

**时间复杂度**：O(n × m)
- n: 丹方需要的材料种类数 (通常3-4)
- m: 背包中灵草总数 (可能很大)

**优化建议**：
```javascript
// 使用Map缓存灵草数量
const herbCount = new Map()
inventoryStore.herbs.forEach(herb => {
  herbCount.set(herb.id, (herbCount.get(herb.id) || 0) + 1)
})

// 检查时直接查询
const checkMaterialsOptimized = (recipe) => {
  return recipe.materials.every(
    material => (herbCount.get(material.herb) || 0) >= material.count
  )
}
```

### 3.3 材料消耗函数

```javascript
/**
 * 消耗材料
 * 当前实现：逐个删除
 */
recipe.materials.forEach(material => {
  for (let i = 0; i < material.count; i++) {
    // 查找该灵草在数组中的位置
    const index = inventoryStore.herbs.findIndex(
      h => h.id === material.herb
    )
    
    // 从背包移除
    if (index > -1) {
      inventoryStore.herbs.splice(index, 1)
    }
  }
})

// 问题分析：
// ❌ 多次findIndex + splice (O(n²))
// ❌ 没有处理缺少的情况
// ❌ 没有原子性保证（可能消耗一半失败）

/**
 * 优化方案：先检查再消耗
 */
const consumeMaterials = (recipe) => {
  // 步骤1：验证
  if (!checkMaterials(recipe)) {
    return false
  }
  
  // 步骤2：记录要删除的草药
  const toRemove = []
  recipe.materials.forEach(material => {
    for (let i = 0; i < material.count; i++) {
      const idx = inventoryStore.herbs.findIndex(
        h => h.id === material.herb
      )
      if (idx > -1) {
        toRemove.push(idx)
      }
    }
  })
  
  // 步骤3：按逆序删除（保持索引正确性）
  toRemove.sort((a, b) => b - a)
  toRemove.forEach(idx => {
    inventoryStore.herbs.splice(idx, 1)
  })
  
  return true
}
```

### 3.4 成功率计算函数

```javascript
/**
 * 炼制成功判定
 */
const craftPill = () => {
  const recipe = selectedRecipe.value
  const grade = pillGrades[recipe.grade]
  
  // 获取修正因子
  const luck = playerInfoStore.luck || 1      // 幸运值
  const alchemyRate = playerInfoStore.alchemyRate || 1  // 炼丹技能
  
  // 计算最终成功率
  const successRate = grade.successRate * luck * alchemyRate
  
  // 注意：这里没有做上下限控制
  // 建议加上：Math.min(Math.max(successRate, 0), 1)
  
  // 判定成功
  if (Math.random() > successRate) {
    // 失败分支
    return
  }
  
  // 成功分支
  consumeMaterials(recipe)
  createPill(recipe)
}

// 概率分布示例：
// 一品丹(90%) + 普通玩家(luck=1, rate=1) = 90%
// 四品丹(60%) + 高手玩家(luck=1.2, rate=1.3) = 93.6%
// 九品丹(10%) + 超级玩家(luck=1.5, rate=1.5) = 22.5%
```

---

## 四、状态管理详解

### 4.1 Pills Store 的职责

```javascript
export const usePillsStore = defineStore('pills', {
  // 状态
  state: () => ({
    pills: [],                    // ✅ 已拥有的丹药
    pillFragments: {},            // ✅ 各丹方的残页数
    pillRecipes: [],              // ✅ 已掌握的丹方列表
    activeEffects: [],            // ✅ 当前生效的效果
    pillsCrafted: 0,              // ✅ 成就相关：总炼制数
    pillsConsumed: 0              // ✅ 成就相关：总使用数
  }),
  
  // 动作
  actions: {
    // 获得残页（来自探索或购买）
    gainPillFragment(recipeId) {
      // 逻辑1：增加该丹方的残页
      if (!this.pillFragments[recipeId]) {
        this.pillFragments[recipeId] = 0
      }
      this.pillFragments[recipeId]++
      
      // 逻辑2：检查是否能合成
      const recipe = pillRecipes.find(r => r.id === recipeId)
      if (recipe && this.pillFragments[recipeId] >= recipe.fragmentsNeeded) {
        // 自动合成
        this.pillFragments[recipeId] -= recipe.fragmentsNeeded
        if (!this.pillRecipes.includes(recipeId)) {
          this.pillRecipes.push(recipeId)
        }
      }
    },
    
    // 炼制丹药
    craftPill(recipeId, herbsStore, playerInfoStore) {
      // 这个函数可能应该在Alchemy.vue中实现
      // 或者需要更多参数才能完整实现
    }
  }
})
```

### 4.2 与其他Store的交互

```
Alchemy.vue 组件内部的交互：
    ↓
usePlayerInfoStore
    ├─ level (计算效果)
    ├─ luck (计算成功率)
    └─ alchemyRate (计算成功率)
    
useInventoryStore
    ├─ herbs (检查材料、消耗材料)
    └─ items (添加丹药)
    
usePillsStore
    ├─ pillRecipes (已掌握列表)
    ├─ pillFragments (残页进度)
    ├─ pills (丹药库存)
    └─ pillsCrafted (统计)
    
useStatsStore
    └─ unlockedPillRecipes (成就统计)
```

---

## 五、前端组件详解

### 5.1 Alchemy.vue 的三个主要计算属性

```javascript
// 计算属性1：已解锁的丹方列表
unlockedRecipes = computed(() => {
  // 返回玩家已掌握的丹方的完整配置对象
  return pillRecipes.filter(recipe => 
    pillsStore.pillRecipes.includes(recipe.id)
  )
  // 时间复杂度：O(n×m) n=总丹方数, m=已掌握数
})

// 计算属性2：选中丹方的效果预览
currentEffect = computed(() => {
  if (!selectedRecipe.value) {
    return { value: 0, duration: 0, successRate: 0 }
  }
  
  const recipe = selectedRecipe.value
  const grade = pillGrades[recipe.grade]
  const effect = calculatePillEffect(recipe, playerInfoStore.level)
  
  return {
    ...effect,
    successRate: grade.successRate
  }
})

// 计算属性3：已掌握 vs 未掌握分组
groupedRecipes = computed(() => {
  const complete = []
  const incomplete = []
  
  pillRecipes.forEach(recipe => {
    const fragments = pillsStore.pillFragments[recipe.id] || 0
    
    if (pillsStore.pillRecipes.includes(recipe.id)) {
      // 已掌握
      complete.push({
        ...recipe,
        fragments: 'N/A',
        fragmentsNeeded: 'N/A'
      })
    } else {
      // 未掌握
      incomplete.push({
        ...recipe,
        fragments,
        fragmentsNeeded: recipe.fragmentsNeeded,
        progress: `${fragments}/${recipe.fragmentsNeeded}`
      })
    }
  })
  
  return { complete, incomplete }
})
```

### 5.2 组件方法分析

```javascript
// 方法1：选择丹方
selectRecipe(recipe) {
  selectedRecipe.value = recipe
  // 触发computed重新计算 currentEffect
}

// 方法2：获取灵草显示名称
getHerbName(herbId) {
  // 硬编码的15种灵草映射表
  // ❌ 性能问题：每次都要遍历
  // ✅ 可以改为Object lookup
  
  const herbNames = {
    'spirit_grass': '灵精草',
    'cloud_flower': '云雾花',
    // ...
  }
  return herbNames[herbId] || herbId
}

// 方法3：检查单个材料状态
getMaterialStatus(material) {
  const ownedCount = inventoryStore.herbs.filter(
    h => h.id === material.herb
  ).length
  return `${ownedCount}/${material.count}`
}

// 方法4：检查所有材料
checkMaterials(recipe) {
  return recipe.materials.every(material => {
    const ownedCount = inventoryStore.herbs.filter(
      h => h.id === material.herb
    ).length
    return ownedCount >= material.count
  })
}

// 方法5：执行炼制
craftPill() {
  // 逻辑流程已在上面详细分析
}

// 方法6：购买残页
buyFragment(recipeId) {
  const recipe = pillRecipes.find(r => r.id === recipeId)
  
  // 计算价格（根据品阶）
  const fragmentPrice = recipe.grade * 100
  // grade = 'grade1' → parseInt('1') × 100 = 100灵石
  // grade = 'grade4' → parseInt('4') × 100 = 400灵石
  
  // 检查灵石
  if (inventoryStore.spiritStones < fragmentPrice) {
    return
  }
  
  // 扣除灵石
  inventoryStore.spiritStones -= fragmentPrice
  
  // 获得残页
  pillsStore.gainPillFragment(recipeId)
}
```

---

## 六、性能优化建议

### 6.1 当前性能瓶颈

| 操作 | 时间复杂度 | 影响 | 优化级别 |
|------|-----------|------|--------|
| checkMaterials | O(n×m) | 中等 | 中 |
| getMaterialStatus | O(n×m) | 高 | 高 |
| getHerbName | O(m) | 低 | 低 |
| unlockedRecipes | O(n×m) | 低 | 低 |

### 6.2 具体优化方案

```javascript
// 优化1：缓存灵草名称映射
const herbNameMap = {
  'spirit_grass': '灵精草',
  'cloud_flower': '云雾花',
  // ... (在模块级别缓存)
}

// 优化2：预计算材料状态
const materialStatus = computed(() => {
  const herbCounts = new Map()
  
  inventoryStore.herbs.forEach(herb => {
    herbCounts.set(
      herb.id, 
      (herbCounts.get(herb.id) || 0) + 1
    )
  })
  
  return herbCounts  // 缓存这个Map
})

// 优化3：使用预计算检查
const checkMaterialsOptimized = (recipe) => {
  return recipe.materials.every(material => 
    (materialStatus.value.get(material.herb) || 0) >= material.count
  )
}

// 优化4：虚拟滚动（如果丹方很多）
// 使用 @vueuse/core 的 useVirtualList
// 只渲染可见的丹方卡片
```

---

## 七、数据流分析

### 7.1 炼制数据流

```
用户点击"开始炼制"
    ↓
craftPill()
    ├─ 检查1: 是否掌握丹方 ✓
    ├─ 检查2: 材料是否充足 ✓
    │
    ├─ 计算成功率
    │  ├─ grade.successRate (基础)
    │  ├─ × luck (幸运值)
    │  └─ × alchemyRate (技能)
    │
    ├─ Math.random() 判定
    │
    ├─ 成功分支:
    │  ├─ consumeMaterials() → inventoryStore.herbs--
    │  ├─ createPill() → inventoryStore.items++
    │  ├─ pillsStore.pillsCrafted++
    │  └─ message.success()
    │
    └─ 失败分支:
       ├─ consumeMaterials() → inventoryStore.herbs--
       ├─ message.error()
       └─ logRef.addLog()
```

### 7.2 残页数据流

```
获得残页 (来自探索或购买)
    ↓
pillsStore.gainPillFragment(recipeId)
    ├─ pillFragments[recipeId]++
    │
    ├─ 判断：fragments >= fragmentsNeeded ?
    │
    ├─ 否:
    │  ├─ 更新进度显示
    │  └─ message.success(`已获得x/y`)
    │
    └─ 是:
       ├─ pillFragments[recipeId] -= fragmentsNeeded
       ├─ pillRecipes.push(recipeId)
       ├─ statsStore.unlockedPillRecipes++
       ├─ achievementCheck() → 解锁成就
       └─ message.success(`成功掌握${name}`)
```

---

## 八、代码质量评分

### 8.1 关键指标

| 指标 | 评分 | 备注 |
|------|------|------|
| 功能完整性 | ⭐⭐⭐⭐ | 丹方、炼制、残页完整 |
| 代码可读性 | ⭐⭐⭐⭐ | 变量名清晰、逻辑清楚 |
| 性能优化 | ⭐⭐⭐ | 存在O(n×m)操作 |
| 错误处理 | ⭐⭐⭐ | 基本覆盖但不完整 |
| 代码复用 | ⭐⭐⭐ | Store使用得当 |
| 扩展性 | ⭐⭐⭐ | 配置驱动，易扩展 |

### 8.2 改进优先级

1. **高优先级**：优化checkMaterials性能
2. **高优先级**：完善丹药效果应用系统
3. **中优先级**：添加购买残页功能UI
4. **中优先级**：优化灵草名称映射
5. **低优先级**：添加丹药收藏夹功能

